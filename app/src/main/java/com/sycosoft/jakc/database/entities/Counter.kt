package com.sycosoft.jakc.database.entities

import androidx.room.ColumnInfo
import androidx.room.Entity
import androidx.room.PrimaryKey
import com.sycosoft.jakc.utils.CounterType

/**
 * Represents the Counter entity in the database.
 *
 * @param id The unique identifier for the counter. (This is autogenerated by the database upon insertion.)
 * @param name The name of the counter.
 * @param description The description for the counter. (Optional)
 * @param currentValue The current value of the counter.
 * @param incrementBy The amount to increment or decrement the counter by each time it's edited.
 * @param type The type of counter this is.
 * @param isGloballyLinked Whether this counter is linked to the global counter.
 * @param resetRow The row to reset the counter to 0. When set to 0, this is ignored.
 * @param maxResets The maximum number of times the counter can be reset. When [resetRow] or this is set to 0, it's ignored.
 * @param currentResets The current number of resets the counter has been made. When [resetRow] is set to 0, this is not incremented.
 * @param owningPartId The id of the part this counter belongs to.
 *
 * @throws IllegalArgumentException if the name is set to blank.
 *
 * @see [CounterType] for list of available counter types.
 *
 * @author Jamie-Rhys Edwards
 * @since v0.0.1
 */
@Entity(tableName = "counters")
data class Counter(
    @PrimaryKey(autoGenerate = true) private val id: Long = 0,
    @ColumnInfo(name = "name") private var name: String,
    @ColumnInfo(name = "description") private var description: String = "",
    @ColumnInfo(name = "current_value") private var currentValue: Long = 0,
    @ColumnInfo(name = "can_go_negative") private var canGoNegative: Boolean = false,
    @ColumnInfo(name = "increment_by") private var incrementBy: Long = 1,
    @ColumnInfo(name = "type") private val type: CounterType = CounterType.Normal,
    @ColumnInfo(name = "globally_linked") private var isGloballyLinked: Boolean = false,
    @ColumnInfo(name = "reset_row") private var resetRow: Long = 0,
    @ColumnInfo(name = "max_resets") private var maxResets: Long = 0,
    @ColumnInfo(name = "current_resets") private var currentResets: Long = 0,
    @ColumnInfo(name = "owning_part_id") private val owningPartId: Long,
) {
    class ExceptionMessages {
        companion object {
            const val NAME_CANNOT_BE_BLANK = "Name cannot be blank"
        }
    }

    init {
        require(name.isNotBlank()) { ExceptionMessages.NAME_CANNOT_BE_BLANK }
    }

    /**
     * Returns the unique identifier for this counter.
     */
    fun id() = id

    /**
     * Returns the name of the counter.
     */
    fun name() = name

    /**
     * When passed a new string, this sets the name of the counter.
     *
     * @param name The new name of the counter to change to.
     *
     * @Throws IllegalArgumentException if the new value is blank.
     */
    fun name(name: String) {
        if (name.isNotBlank()) {
            this.name = name
        } else {
            throw IllegalArgumentException(ExceptionMessages.NAME_CANNOT_BE_BLANK)
        }
    }

    /**
     * Returns the description of the counter.
     */
    fun description() = description

    /**
     * When passed a new string, this sets the description of the counter.
     *
     * @param description The new description of the counter to change to.
     */
    fun description(description: String ) { this.description = description }

    /**
     * Returns the current value of the counter.
     */
    fun currentValue() = currentValue

    /**
     * Returns if the counter can go into negative values.
     */
    fun canGoNegative() = canGoNegative

    /**
     * When passed a new value, this sets the value of if the counter can go into negative values or not.
     */
    fun canGoNegative(canGoNegative: Boolean) { this.canGoNegative = canGoNegative }

    /**
     * Increments the [currentValue] by the [incrementBy] value.
     */
    fun increment() {

        if (resetRow > 0) {
            if (currentResets == maxResets) {
                return
            }
            if (currentValue == resetRow) {
                currentValue = 0
                incrementCurrentResets()
                return
            }
        }

        currentValue += incrementBy()
    }

    /**
     * Decrements the [currentValue] by the [incrementBy] value.
     */
    fun decrement() {
        if (currentValue >= 0L && !canGoNegative) {
            currentValue = 0
            return
        }

        currentValue -= incrementBy()
    }

    /**
     * Returns the increment by value.
     */
    fun incrementBy() = incrementBy

    /**
     * Sets the increment by value to the given amount.
     *
     * @param incrementBy The new increment by value to change to.
     */
    fun incrementBy(incrementBy: Long) { this.incrementBy = incrementBy }

    /**
     * Returns the type of counter this is set to.
     *
     * @see [CounterType] for list of available counter types.
     */
    fun type() = type

    /**
     * Returns whether this counter is linked to the Global Counter.
     */
    fun isGloballyLinked() = isGloballyLinked

    /**
     * Sets whether this counter is linked to the Global Counter.
     */
    fun isGloballyLinked(isGloballyLinked: Boolean) { this.isGloballyLinked = isGloballyLinked }

    /**
     * Returns the reset row value.
     */
    fun resetRow() = resetRow

    /**
     * Sets the value of the reset row.
     *
     * @param resetRow The new value of the reset row.
     */
    fun resetRow(resetRow: Long) { this.resetRow = resetRow }

    /**
     * Returns the maximum number of times the counter can be reset.
     */
    fun maxResets() = maxResets

    /**
     * Sets the maximum number of times the counter can be reset.
     */
    fun maxResets(maxResets: Long) { this.maxResets = maxResets }

    /**
     * Returns the current number of times the counter has been reset.
     */
    fun currentResets() = currentResets

    /**
     * Increments the current number of times the counter has been reset.
     */
    fun incrementCurrentResets() {
        // If resetRow is not greater than zero, there is nothing to do.
        if (resetRow > 0) {
            // Check if currentResets already matches maxResets. If it does, there is nothing to do.
            if (currentResets == maxResets) {
                return
            }

            // No further checks needed, just increment the value.
            currentResets++
        }
    }

    /**
     * Decrements the current number of times the counter has been reset.
     */
    fun decrementCurrentResets() {
        // If resetRow is not greater than zero, there is nothing to do.
        if (resetRow > 0) {
            // Check if currentResets already matches 0L. If it does, there is nothing to do.
            if (currentResets == 0L) {
                return
            }

            // No further checks needed, just decrement the value.
            currentResets--
        }
    }

    /**
     * Returns the unique identifier of the part this counter belongs to.
     */
    fun owningPartId() = owningPartId
}